package edu.grinnell.csc207.soundsofsorting.sorts;

import java.util.ArrayList;
import java.util.List;

import edu.grinnell.csc207.soundsofsorting.sortevents.CompareEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.CopyEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SortEvent;
import edu.grinnell.csc207.soundsofsorting.sortevents.SwapEvent;

/**
 * A collection of sorting algorithms.
 */
public class Sorts {
    /**
     * Swaps indices <code>i</code> and <code>j</code> of array <code>arr</code>.
     * @param <T> the carrier type of the array
     * @param arr the array to swap
     * @param i the first index to swap
     * @param j the second index to swap
     */
    public static <T> void swap(T[] arr, int i, int j) {
        T tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    /**
     * Sorts the array according to the bubble sort algorithm:
     * <pre>
     * [ unprocessed | i largest elements in order ]
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> bubbleSort(T[] arr){
        boolean arrayinorder = false;
        while (arrayinorder == false) {
            arrayinorder = true;
            for (int iter = 0; iter < (arr.length - 1); iter++) {
                if (arr[iter].compareTo(arr[iter + 1]) > 0) {
                    swap(arr, iter, iter + 1);
                    arrayinorder = false;
                }
            }

        }

        return null;
    }

    /**
     * Sorts the array according to the selection sort algorithm:
     * <pre>
     * [ i smallest elements in order | unprocessed ]
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> selectionSort(T[] arr){
        for (int i = 0; i < arr.length; i++) {
        for (int j = i; j < arr.length; j++) {
        if (arr[i].compareTo(arr[j]) > 0) {
            swap(arr, i, j);
            }
        }
        }
        return null;
    }

    /**
     * Sorts the array according to the insertion sort algorithm:
     * <pre>
     * [ i elements in order | unprocessed ] 
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> insertionSort(
            T[] arr) {
        for(int iter = 0; iter < arr.length; iter++){
            T save = arr[iter];
            int iter2;
            for (iter2 = 0; iter2 < iter; iter2++){
                if (save.compareTo(arr[iter2]) < 0)
                    break;
                }
                for(int iter3 = iter; iter3 > iter2; iter3--){
                    arr[iter3] = arr[iter3 - 1];
                }
                arr[iter2] = save;
            }
        return null;
    }

    /**
     * Sorts the array according to the merge sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> mergeSort(
            T[] arr) {
                mergeSortHelper(arr, arr, arr.length, 0);
                return null;
            }
        
    public static <T extends Comparable<? super T>> void mergeSortHelper(T[] arr, T[] arr2, int hi, int lo) {
        if(lo >= hi) {
            if (arr[hi].compareTo(arr[lo]) > 0) {
                swap(arr2, hi, lo);
                }
                return ;
        }
        int midPoint = arr.length/2;
        int pointerFir = lo;
        int pointerSec = midPoint;
        for (int i = lo; i < hi; i++) {
            if (pointerFir == midPoint) {
                arr2[i] = arr[pointerSec];
                pointerSec++;
            } else if (pointerSec == hi) {
                arr2[i] = arr[pointerFir];
                pointerFir++;
            } else if (arr[pointerFir].compareTo(arr[pointerSec]) < 0) {
                arr2[i] = arr[pointerFir];
                pointerFir++;
            } else if (arr[pointerSec].compareTo(arr[pointerFir]) < 0) {
                arr2[i] = arr[pointerSec];
                pointerSec++;
            } 
        }
        System.arraycopy(arr2, 0, arr, 0, arr.length);
        mergeSortHelper(arr, arr2, hi, midPoint + 1);
        mergeSortHelper(arr, arr2, midPoint, lo);
        //return null;
    }

    /**
     * Sorts the array according to the quick sort algorithm.
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> quickSort(T[] arr) {
        List<SortEvent<Integer>> l = new ArrayList<SortEvent<Integer>>();
        quickSortHelper(arr, 0, arr.length - 1, l);
        return l;
    }

    /**
     * 
     * @param <T>
     * @param arr
     * @param hi exclusive
     * @param lo inclusive
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> quickSortHelper(T[] arr, int lo, int hi, 
                                                                                             List<SortEvent<Integer>> l) {
        int pivot = hi;
        int pointerLo = lo;
        int pointerHi = hi - 1;
        boolean cont = true;
        l.add(new CompareEvent(lo, hi));
        if(lo >= hi - 1) {
            return l;
        } else {
            while (cont) {
                while (arr[pointerLo].compareTo(arr[pivot]) < 0 && pointerHi != pointerLo) {
                    l.add(new CompareEvent(pointerLo, pivot));
                    l.add(new CompareEvent(pointerHi, pointerLo));
                    pointerLo++;
                }
                while (arr[pointerHi].compareTo(arr[pivot]) >= 0 && pointerHi != pointerLo) {
                    l.add(new CompareEvent(pointerHi, pivot));
                    l.add(new CompareEvent(pointerHi, pointerLo));
                    pointerHi--;
                } 

                if (pointerHi == pointerLo) {
                    l.add(new CompareEvent(pointerHi, pointerLo));
                    if (arr[pointerLo].compareTo(arr[hi]) >= 0) {
                        l.add(new CompareEvent(pointerLo, hi));
                        swap(arr, pointerLo, hi);
                        l.add(new SwapEvent(pointerLo, hi));
                    }
                    cont = false;
                } else {
                    swap(arr, pointerLo, pointerHi);
                    l.add(new SwapEvent(pointerLo, pointerHi));
                }
            }
            quickSortHelper(arr, pointerHi, hi, l); //changed 1st arg from arr.
            quickSortHelper(arr, lo, pointerHi, l);
            return l;
        }
    }


    /**
     * Sorts the array according to my rock sort algorithm:
     * <pre>
     * [ unprocessed | i-length largest elements in order ]
     * </pre>
     * @param <T> the carrier type of the array
     * @param arr the array to sort
     * @return the sort events generated by this sort
     */
    public static <T extends Comparable<? super T>> List<SortEvent<Integer>> rockSort(T[] arr){
    boolean arrayinorder = false;
        while (arrayinorder == false) {
            arrayinorder = true;
            for (int iter = (arr.length - 1); iter > 0; iter--) {
                if (arr[iter].compareTo(arr[iter - 1]) < 0) {
                    swap(arr, iter, iter + 1);
                    arrayinorder = false;
                }
            }

        }
        return null;
    }

    <T> void eventSort(T[] l, List<SortEvent<T>> events) {
        while (!events.isEmpty()) {
            events.remove(0).apply(l);
        }
    }
}
